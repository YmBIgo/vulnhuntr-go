const LFI_PROMPT = `Combine the code in <file_code> and <context_code> then analyze the code for remotely-exploitable Local File Inclusion (LFI) vulnerabilities in Go by following the remote user-input call chain of code.

LFI-Specific Focus Areas for Go:
1. High-Risk Functions and Methods:
   - os.Open(), os.OpenFile()
   - ioutil.ReadFile(), ioutil.ReadDir() (or os.ReadFile() in newer Go versions)
   - filepath.Join() for constructing file paths
   - Custom file reading or file serving functions

2. Path Traversal Opportunities:
   - User-controlled file paths or file names
   - Dynamic inclusion or retrieval of files based on user input

3. File Operation Wrappers:
   - Template engines (e.g., html/template, text/template) that load files
   - Custom file management or HTTP file serving handlers

4. Indirect File Inclusion:
   - Configuration file parsing and dynamic loading (e.g., using encoding/json or encoding/xml)
   - Plugin or extension loading systems (e.g., plugin.Open)
   - Log file viewers or debug endpoints that allow file path input

5. Example LFI-Specific Bypass Techniques are provided in <example_bypasses></example_bypasses> tags

When analyzing, consider:
- How user input influences file paths or names
- Effectiveness of path sanitization and validation (e.g., usage of filepath.Clean())
- Potential for null byte injection or encoding tricks (noting Go's string handling specifics)
- Interaction with file system access controls and environment settings`

const RCE_PROMPT = `Combine the code in <file_code> and <context_code> tags then analyze for remotely-exploitable Remote Code Execution (RCE) vulnerabilities in Go by following the remote user-input call chain of code.

RCE-Specific Focus Areas for Go:
1. High-Risk Functions and Methods:
   - os/exec package: exec.Command(), exec.CommandContext()
   - Shell command composition and execution through exec functions
   - Any third-party libraries or packages that provide dynamic code evaluation or compilation

2. Indirect Code Execution:
   - Misuse of the reflect package leading to arbitrary function calls
   - Template engines (e.g., text/template, html/template) if used in a way that evaluates dynamic expressions
   - Custom plugin systems or dynamic module loaders (e.g., plugin.Open)

3. Command Injection Vectors:
   - Unsafe concatenation or composition of shell commands with user input
   - Unsanitized user input used in command arguments passed to exec functions

4. Deserialization and Unmarshaling Vulnerabilities:
   - Unsafe deserialization/unmarshaling of user-controlled data (e.g., using encoding/gob, json.Unmarshal, yaml unmarshal functions with untrusted input)

5. Example RCE-Specific Bypass Techniques are provided in <example_bypasses></example_bypasses> tags

When analyzing, consider:
- How user input flows into these high-risk areas and influences command construction or dynamic function calls
- Potential for filter evasion or bypassing of sanitization measures
- Environment-specific factors (e.g., Go version, operating system) affecting exploitability`

const XSS_PROMPT = `Combine the code in <file_code> and <context_code> tags then analyze for remotely-exploitable Cross-Site Scripting (XSS) vulnerabilities in Go by following the remote user-input call chain of code.

XSS-Specific Focus Areas for Go:
1. High-Risk Functions and Methods:
   - Template rendering functions in the html/template and text/template packages
   - Manual HTML or JavaScript string concatenation or manipulation
   - Any libraries or helper functions used for dynamic HTML response generation

2. Output Contexts:
   - Unescaped output in HTML content generated by templates
   - Insertion of user input into HTML attribute values without proper encoding
   - Embedding of user-controlled data within JavaScript code or JSON responses

3. Input Handling:
   - Reflection of user input in HTTP responses or web pages
   - Use (or absence) of input sanitization and output encoding functions (e.g., template.HTMLEscapeString, template.JSEscapeString)
   - Custom middleware or input filtering mechanisms that process user data

4. Indirect XSS Vectors:
   - Stored user input in databases, files, or logs that is later rendered in web pages
   - URL parameter reflection or usage within dynamically generated content
   - HTTP header injection points where unsanitized data might be reflected

5. Example XSS-Specific Bypass Techniques are provided in <example_bypasses></example_bypasses> tags

When analyzing, consider:
- How user input flows into HTML, JavaScript, or JSON contexts within the application
- The effectiveness of input validation, sanitization, and output encoding measures (especially within Go templates)
- Potential for filter evasion or bypass techniques using encoding or obfuscation
- The impact of security measures such as Content Security Policy (CSP) if implemented`

const AFO_PROMPT = `Combine the code in <file_code> and <context_code> tags then analyze for remotely-exploitable Arbitrary File Overwrite (AFO) vulnerabilities in Go by following the remote user-input call chain of code.

AFO-Specific Focus Areas for Go:
1. High-Risk Functions and Methods:
   - os.Create(), os.OpenFile() with write flags (e.g., os.O_WRONLY, os.O_CREATE, os.O_TRUNC)
   - os.Rename(), os.Remove(), os.WriteFile() (or ioutil.WriteFile() in older versions)
   - Custom file writing or update functions

2. Path Traversal Opportunities:
   - User-controlled file paths or filenames used in write operations
   - Dynamic file path construction using filepath.Join() or string concatenation

3. File Operation Wrappers:
   - Custom file management functions or types
   - Frameworks or libraries that encapsulate file handling methods

4. Indirect File Writes:
   - Log file manipulation or rotation functions accepting user input
   - Configuration file updates, cache file creation, or temporary file handling routines

5. Example AFO-Specific Bypass Techniques are provided in <example_bypasses></example_bypasses> tags

When analyzing, consider:
- How user input influences file paths or names in file write operations
- Effectiveness of path sanitization and validation (e.g., usage of filepath.Clean())
- Potential for race conditions or TOCTOU vulnerabilities in file operations`

const SSRF_PROMPT = `Combine the code in <file_code> and <context_code> tags then analyze for remotely-exploitable Server-Side Request Forgery (SSRF) vulnerabilities in Go by following the remote user-input call chain of code.

SSRF-Specific Focus Areas for Go:
1. High-Risk Functions and Methods:
   - net/http package functions: http.Get(), http.Post(), http.NewRequest(), http.Client.Do()
   - Custom HTTP clients or external libraries (e.g., fasthttp)
   - API calls to external services via HTTP/HTTPS

2. URL Parsing and Validation:
   - Usage of the net/url package for URL parsing
   - Custom URL validation and sanitization routines

3. Indirect SSRF Vectors:
   - Functions that load remote content (e.g., image processors, PDF generators) using URL inputs
   - XML parsers with external entity processing (if applicable)
   - File inclusion functions that retrieve content from remote URLs

4. Cloud Metadata Access:
   - Requests to cloud provider metadata URLs (e.g., AWS, GCP, Azure metadata endpoints)

5. Example SSRF-Specific Bypass Techniques are provided in <example_bypasses></example_bypasses> tags

When analyzing, consider:
- How user input influences outgoing network requests
- Effectiveness of URL validation and whitelisting approaches
- Potential for DNS rebinding or time-of-check to time-of-use (TOCTOU) attacks`

const SQLI_PROMPT = `Combine the code in <file_code> and <context_code> tags then analyze for remotely-exploitable SQL Injection (SQLI) vulnerabilities in Go by following these steps:

1. Identify Entry Points:
   - Locate all points where remote user input is received (e.g., HTTP handler parameters, query parameters, form submissions).

2. Trace Input Flow:
   - Follow the user input as it flows through the application.
   - Note any transformations or manipulations applied to the input.

3. Locate SQL Operations:
   - Find all locations where SQL queries are constructed or executed.
   - Pay special attention to:
     - Direct SQL query construction using string concatenation or formatting (e.g., fmt.Sprintf with SQL statements) in functions like db.Query(), db.Exec(), etc.
     - ORM methods or libraries (e.g., GORM, sqlx) that accept raw SQL queries.
     - Custom query builders that may incorporate user input.

4. Analyze Input Handling:
   - Examine how user input is incorporated into SQL queries.
   - Look for:
     - String concatenation or formatting of SQL queries with user input.
     - Proper use of parameterized queries or prepared statements (e.g., using '?' or '$1' placeholders).
     - Dynamic table or column name usage without proper validation.

5. Evaluate Security Controls:
   - Identify any input validation, sanitization, or escaping mechanisms.
   - Assess the effectiveness of these controls against SQLI attacks.

6. Consider Bypass Techniques:
   - Analyze potential ways to bypass identified security controls.
   - Reference SQLI-specific bypass techniques provided.

7. Assess Impact:
   - Evaluate the potential impact if the vulnerability is exploited.
   - Consider the sensitivity of the data accessible through the vulnerable query.

When analyzing, consider:
- The complete path from user input to SQL execution.
- Any gaps in the analysis where more context is needed.
- The effectiveness of any security measures in place.
- Potential for filter evasion in different database contexts.`

const IDOR_PROMPT = `Combine the code in <file_code> and <context_code> tags then analyze for remotely-exploitable Insecure Direct Object Reference (IDOR) vulnerabilities in Go.

IDOR-Specific Focus Areas for Go:
1. Look for code segments involving IDs, keys, filenames, session tokens, or any other unique identifiers that might be used to access resources (e.g., userID, fileID, orderID).

2. Common Locations:
   - URLs/Routes: Check if IDs are passed directly in URL parameters (e.g., /user/{userID}/profile) handled by net/http or router frameworks (e.g., gorilla/mux).
   - Query Parameters: Inspect if IDs are included as query parameters in HTTP requests.
   - Form Parameters: Look for IDs submitted via form data (using request.Form or request.PostForm).
   - API Endpoints: Examine API requests where IDs are sent in JSON payloads or HTTP headers.

3. Ensure Authorization is Enforced:
   - Verify that the code checks the user's authorization before allowing access to the resource identified by the ID.
   - Look for explicit authorization checks (e.g., functions like checkUserPermission, isAuthorized, or middleware enforcing access control) immediately after the object reference is obtained.

4. Common Functions and Middleware:
   - Review the usage of custom middleware or helper functions that validate user permissions.
   - Absence or misconfiguration of such checks could indicate a potential IDOR vulnerability.

5. Example IDOR-Specific Bypass Techniques are provided in <example_bypasses></example_bypasses> tags.

When analyzing, consider:
- How user input flows into the code handling resource identifiers.
- The presence and correctness of authentication/authorization logic.
- Whether the application properly validates that the requesting user is allowed to access the targeted resource.`

export const VULN_SPECIFIC_BYPASSES_AND_PROMPTS = {
    LFI: {
        prompt: LFI_PROMPT,
        bypasses: [
            "../../../../etc/passwd",
            "/proc/self/environ",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=",
            "file:///etc/passwd",
            "C:\\win.ini",
            "/?../../../../../../../etc/passwd"
        ]
    },
    RCE: {
        prompt: RCE_PROMPT,
        bypasses: [
            "exec.Command(\"sh\", \"-c\", \"id\")",
            "exec.CommandContext(ctx, \"sh\", \"-c\", \"id\")",
            "reflect.ValueOf(exec.Command).Call([]reflect.Value{reflect.ValueOf(\"sh\"), reflect.ValueOf(\"-c\"), reflect.ValueOf(\"id\")})",
            "f:=exec.Command; f(\"sh\", \"-c\", \"id\")",
            "\"ex\"+\"ec.Command(\\\"sh\\\", \\\"-c\\\", \\\"id\\\")\"",
            "exec\\x2eCommand(\"sh\", \"-c\", \"id\")",
            "`sh -c id`"
        ]
    },
    SSRF: {
        prompt: SSRF_PROMPT,
        bypasses: [
            "http://0.0.0.0:22",
            "file:///etc/passwd",
            "dict://127.0.0.1:11211/",
            "ftp://anonymous:anonymous@127.0.0.1:21",
            "gopher://127.0.0.1:9000/_GET /"
        ]
    },
    AFO: {
        prompt: AFO_PROMPT,
        bypasses: [
            "../../../etc/passwd%00.jpg",
            "main.go;.jpg",
            ".htaccess",
            "/proc/self/cmdline",
            "../../config/config.go/."
        ]
    },
    SQLI: {
        prompt: SQLI_PROMPT,
        bypasses: [
            "' UNION SELECT username, password FROM users--",
            "1 OR 1=1--",
            "admin'--",
            "1; DROP TABLE users--",
            "' OR '1'='1"
        ]
    },
    XSS: {
        prompt: XSS_PROMPT,
        bypasses: [
            "<script>alert(document.domain)</script>",
            "\"><script>alert('XSS')</script>",
            "<img src='x' onerror='alert(\"XSS\")'>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
    },
    IDOR: {
        prompt: IDOR_PROMPT,
        bypasses: []
    }
}

export const INITIAL_ANALYSIS_PROMPT_TEMPLATE = `Analyze the code in <file_code> tags for potential remotely exploitable vulnerabilities:
1. Identify all remote user input entry points (e.g., API endpoints, form submissions) and if you can't find that, request the necessary classes or functions in the <context_code> tags.
2. Locate potential vulnerability sinks for:
   - Local File Inclusion (LFI)
   - Arbitrary File Overwrite (AFO)
   - Server-Side Request Forgery (SSRF)
   - Remote Code Execution (RCE)
   - Cross-Site Scripting (XSS)
   - SQL Injection (SQLI)
   - Insecure Direct Object Reference (IDOR)
3. Note any security controls or sanitization measures encountered along the way so you can craft bypass techniques for the proof of concept (PoC).
4. Highlight areas where more context is needed to complete the analysis.

Be generous and thorough in identifying potential vulnerabilities as you'll analyze more code in subsequent steps so if there's just a possibility of a vulnerability, include it the <vulnerability_types> tags.`

export const GUIDELINES_TEMPLATE = `Reporting Guidelines:
1. JSON Format:
   - Provide a single, well-formed JSON report combining all findings.
   - Use null for any aspect of the report that you lack the necessary information for.
   - Place your step-by-step analysis in the scratchpad field, before doing a final analysis in the analysis field.

2. Context Requests:
   - Functions: Use func_name,ClassName.method_name
   - Important: Do not request code from standard libraries or third-party packages. Simply use what you know about them in your analysis.

3. Vulnerability Reporting:
   - Report only remotely exploitable vulnerabilities (no local access/CLI args).
   - Always include at least one vulnerability_type field when requesting context.
   - Provide a confidence score (0-10) and detailed justification for each vulnerability.
     - If your proof of concept (PoC) exploit does not start with remote user input via remote networking calls such as remote HTTP, API, or RPC calls, set the confidence score to 6 or below.

4. Proof of Concept:
   - Include a PoC exploit or detailed exploitation steps for each vulnerability.
   - Ensure PoCs are specific to the analyzed code, not generic examples.
   - Review the code path of the potential vulnerability and be sure that the PoC bypasses any security controls in the code path.`

export const ANALYSIS_APPROACH_TEMPLATE = `Analysis Instructions:
1. Comprehensive Review:
   - Thoroughly examine the content in <file_code>, <context_code> tags (if provided) with a focus on remotely exploitable vulnerabilities.

2. Vulnerability Scanning:
   - You only care about remotely exploitable network related components and remote user input handlers.
   - Identify potential entry points for vulnerabilities.
   - Consider non-obvious attack vectors and edge cases.

3. Code Path Analysis:
   - Very important: trace the flow of user input from remote request source to function sink.
   - Examine input validation, sanitization, and encoding practices.
   - Analyze how data is processed, stored, and output.

4. Security Control Analysis:
   - Evaluate each security measure's implementation and effectiveness.
   - Formulate potential bypass techniques, considering latest exploit methods.

6. Context-Aware Analysis:
   - If this is a follow-up analysis, build upon previous findings in <previous_analysis> using the new information provided in the <context_code>.
   - Request additional context code as needed to complete the analysis and you will be provided with the necessary code.
   - Confirm that the requested context class or function is not already in the <context_code> tags from the user's message.

7. Final Review:
   - Confirm your proof of concept (PoC) exploits bypass any security controls.
   - Double-check that your JSON response is well-formed and complete.`

export const SYS_PROMPT_TEMPLATE = `You are the world's foremost expert in Python security analysis, renowned for uncovering novel and complex vulnerabilities in web applications. Your task is to perform an exhaustive static code analysis, focusing on remotely exploitable vulnerabilities including but not limited to:

1. Local File Inclusion (LFI)
2. Remote Code Execution (RCE)
3. Server-Side Request Forgery (SSRF)
4. Arbitrary File Overwrite (AFO)
5. SQL Injection (SQLI)
6. Cross-Site Scripting (XSS)
7. Insecure Direct Object References (IDOR)

Your analysis must:
- Meticulously track user input from remote sources to high-risk function sinks.
- Uncover complex, multi-step vulnerabilities that may bypass multiple security controls.
- Consider non-obvious attack vectors and chained vulnerabilities.
- Identify vulnerabilities that could arise from the interaction of multiple code components.

If you don't have the complete code chain from user input to high-risk function, strategically request the necessary context to fill in the gaps in the <context_code> tags of your response.

The project's README summary is provided in <readme_summary> tags. Use this to understand the application's purpose and potential attack surfaces.

Remember, you have many opportunities to respond and request additional context. Use them wisely to build a comprehensive understanding of the application's security posture.

Output your findings in JSON format, conforming to the schema in <response_format> tags.`

export const RESPONSE_FORMAT = {
    scratchpad: {
        type: "string",
        comment: "Your step-by-step analysis process. Output in plaintext with no line breaks."
    },
    analysis: {
        type: "string",
        comment: "Your final analysis. Output in plaintext with no line breaks."
    },
    poc: {
        type: "string",
        comment:"Proof-of-concept exploit, if applicable."
    },
    confidence_score: {
        type: "number",
        comment: "0-10, where 0 is no confidence and 10 is absolute certainty because you have the entire user input to server output code path."
    },
    vulnerability_types: {
        type: `("LFI" | "RCE" | "SSRF" | "AFO" | "SQLI" | "XSS" | "IDOR")[]`,
        comment: "The types of identified vulnerabilities"
    },
    context_code: {
        type: `{name: string, reason: string, code_line: string}[]`,
        comment: "List of context code items requested for analysis, one function or class name per item. No standard library or third-party package code."
    }
}